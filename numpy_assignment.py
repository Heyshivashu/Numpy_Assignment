# -*- coding: utf-8 -*-
"""Numpy_Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NrT_VB3R_tM1Ha9mqv2dfm5XSozHJGlX

## Name: Shivanshu Singh Parihar
# Batch : September 2024
# Assignment Date: 25 Oct 2024
# Assignment : Numpy Theory
## Theoretical Questions:

###                                 Assignment -5

**1.	Explain the purpose and advantages of NumPy in scientific computing and data analysis. How does it enhance Python's capabilities for numerical operations?**

Ans: NumPy is a fundamental library for scientific computing and data analysis in Python. It provides a high-performance multidimensional array object and tools for working with these arrays. Here’s a detailed look at its purpose, advantages, and how it enhances Python’s capabilities:

# Purpose of NumPy
*  Multidimensional Arrays: NumPy introduces the ndarray object, a powerful and flexible array structure that supports large, multi-dimensional arrays and matrices. This is crucial for scientific computing where complex data structures and operations are often required.

*  Mathematical Functions: It provides a wide range of mathematical functions to perform operations on arrays. These include basic operations like addition and multiplication, as well as more advanced functions like trigonometric functions, statistical functions, and linear algebra operations.

*  Interoperability: NumPy arrays serve as a base for other scientific libraries like SciPy, pandas, and scikit-learn, making it easier to perform complex analyses and data manipulation.

# Advantages of NumPy
*  Performance: NumPy is designed for high performance on large arrays and matrices. Its array operations are implemented in C, which means they execute faster than equivalent operations performed in pure Python. The use of contiguous memory blocks and vectorization (operations applied simultaneously across array elements) further enhances speed.

*  Vectorization: NumPy supports vectorized operations, which means operations can be applied element-wise without the need for explicit loops. This leads to more concise and readable code as well as performance improvements due to optimized C-based implementations.

*  Broadcasting: NumPy's broadcasting rules allow operations on arrays of different shapes and sizes, facilitating efficient computations. For instance, you can perform arithmetic operations between a scalar and an array without having to explicitly replicate the scalar across the array.

*  Integration with Other Libraries: NumPy serves as the foundational library for scientific computing in Python. Many other libraries, such as SciPy (for scientific and technical computing), pandas (for data manipulation and analysis), and scikit-learn (for machine learning), rely on NumPy for array operations and data handling.

*  Ease of Use: NumPy provides a wide range of easy-to-use functions and methods for data manipulation, such as reshaping arrays, slicing, indexing, and aggregating data. This simplicity makes it accessible even to those new to programming or scientific computing.

*  Memory Efficiency: NumPy arrays are more memory-efficient compared to Python lists. This is because NumPy uses a fixed-size data type for its elements and stores them in contiguous blocks of memory, which minimizes overhead and improves cache performance.

*  Rich Ecosystem: The extensive ecosystem of functions and tools provided by NumPy, including those for linear algebra, Fourier transforms, and random number generation, makes it a comprehensive tool for numerical and scientific computations.

# Enhancing Python’s Capabilities
*   Speed and Efficiency: Python, being an interpreted language, is generally slower for numerical computations compared to compiled languages. NumPy enhances Python’s capabilities by offloading the computation-heavy tasks to its underlying C implementations, thus improving performance.

*  Ease of Numerical Computation: Prior to NumPy, numerical computations in Python were less straightforward and often required manual implementation of algorithms. NumPy abstracts away much of this complexity, providing a set of pre-built, optimized functions that simplify numerical programming.

*  Data Handling and Transformation: NumPy’s array operations and methods allow for efficient data handling and transformation. This is crucial for preprocessing data before performing more complex analyses or modeling tasks.

*  Community and Support: Being a widely adopted library, NumPy benefits from a large community of users and contributors. This results in a wealth of resources, documentation, and third-party tools that enhance its functionality and usability.

**2. Compare and contrast np.mean() and np.average() functions in NumPy. When would you use one over the other.**

Ans: In NumPy, np.mean() and np.average() are two functions used to calculate the average of numerical data, but they have some differences in functionality. Here’s a detailed comparison:

# np.mean()
*  Purpose: Computes the arithmetic mean of the elements in an array.

*  Syntax: numpy.mean(a, axis=None, dtype=None, out=None, keepdims=False)

*  a: Array-like input.

*  axis: Axis or axes along which the means are computed. By default, it computes the mean of the flattened array.

*  dtype: Data type used for the computation. Defaults to the data type of a.

*  out: An alternative output array in which to place the result.

*  keepdims: Whether to retain the reduced dimensions as single-dimensional or not.

*  Default Behavior: Calculates the mean of all elements in the array by default.

*  Usage: Use np.mean() when you want a simple arithmetic mean of the array elements without any additional weighting.

# np.average()

*  Purpose: Computes the weighted average of elements in an array.

*  Syntax: numpy.average(a, axis=None, weights=None, returned=False)

*  a: Array-like input.

*  axis: Axis or axes along which the averages are computed. By default, it computes the average of the flattened array.

*  weights: Array of weights associated with the data. If provided, the average is computed as a weighted average.

*  returned: If True, it also returns the sum of the weights.

*  Default Behavior: Calculates the average of all elements in the array. If weights are provided, it computes the weighted average.

*  Usage: Use np.average() when you need to compute a weighted average, where different elements contribute differently to the result based on their weights.

#Key Differences Weights:

*  np.mean() does not handle weights. It computes a simple arithmetic mean. np.average() can handle weights, allowing for weighted averages. Functionality:

*  np.mean() is straightforward and typically faster for computing an unweighted mean. np.average() provides more flexibility with its support for weights and can also return the sum of weights when required. Output:

Both functions can work along specified axes and can handle multidimensional arrays. np.average() can return additional information (the sum of weights) when returned=True.

# When to Use Each
*  Use np.mean() when you want to compute the simple mean of an array and do not need to consider weights

import numpy as np data = [1, 2, 3, 4, 5] mean_value = np.mean(data) # Outputs 3.0

*  Use np.average() when you need to calculate a weighted average where different elements have different levels of significance

import numpy as np data = [1, 2, 3, 4, 5] weights = [0.1, 0.2, 0.3, 0.2, 0.2] weighted_average = np.average(data, weights=weights) # Computes weighted average.

**3. Describe the methods for reversing a NumPy array along different axes. Provide examples for 1D and 2D arrays.**

Ans: Reversing a NumPy array along different axes can be accomplished using various techniques.methods for both 1D and 2D arrays are:

*  Reversing a 1D NumPy Array For a 1D array: Using Slicing
"""

import numpy as np

# Create a 1D array
arr = np.array([1, 2, 3, 4, 5])

# Reverse the array
reversed_arr = arr[::-1] #arr[::-1] creates a new array that starts from the end of arr and moves backwards, effectively reversing it.

print("Original array:", arr)
print("Reversed array:", reversed_arr)

"""* Reversing a 2D NumPy Array For a 2D array, We can reverse the array along specific axes.

a)Reversing Along Axis 0 (Rows)

b)Reversing Along Axis 1 (Rows)

c)Reversing Along Both Axes
"""

import numpy as np
# Create a 2D array
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# Reverse the array along axis 0
reversed_axis0 = arr[::-1, :] #arr[::-1, :] reverses the rows of the array. The : ensures that all columns
                              #are kept in place while only the rows are reversed
print("Original array:\n", arr)
print("Reversed along axis 0:\n", reversed_axis0)

# Reverse the array along axis 1
reversed_axis1 = arr[:, ::-1]#arr[:, ::-1] reverses the columns of the array. The : ensures that all rows
                            #are kept in place while only the columns are reversed.
print("Original array:\n", arr)
print("Reversed along axis 1:\n", reversed_axis1)

import numpy as np

# Create a 2D array
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# Reverse the array along both axes by combining slicing operations
reversed_both_axes = arr[::-1, ::-1] # arr[::-1, ::-1] reverses the rows and columns of the array. This effectively flips
                                      #the array both vertically and horizontally.
print("Original array:\n", arr)
print("Reversed along both axes:\n", reversed_both_axes)

"""**4.How can you determine the data type of elements in a NumPy array? Discuss the importance of data types in memory management and performance.**

Ans: Determining the data type of elements in a NumPy array is a fundamental aspect of working with NumPy. The data type of the elements in an array affects how data is stored in memory and how operations on the array are performed. Here’s how we can determine the data type and why it matters for memory management and performance.

Determining the Data Type To determine the data type of the elements in a NumPy array, you can use the dtype attribute of the array. Here’s an example:
"""

import numpy as np

# Create a NumPy array
arr = np.array([1, 2, 3, 4, 5])

# Determine the data type of the elements
data_type = arr.dtype
print("Data type of array elements:", data_type)

"""Data Types in NumPy NumPy supports a wide variety of data types including:

* Integers:

1). int8, int16, int32, int64, etc.

2). Unsigned Integers: uint8, uint16, uint32, uint64, etc.

3). Floating-Point Numbers: float16, float32, float64, etc.

4). Complex Numbers: complex64, complex128, etc.

5). Others: bool, str, object, etc.

* Importance of Data Types in Memory Management and Performance:

memory Usage: Different data types require different amounts of memory. For example, int8 takes 1 byte, int32 takes 4 bytes, and int64 takes 8 bytes. Choosing a smaller data type can significantly reduce memory usage, which is crucial when working with large datasets. Floating-point numbers like float32 use less memory than float64. If high precision is not required, using float32 instead of float64 can save memory.

* Performance:

Computational Speed: Operations on smaller data types are generally faster due to reduced computational load. For example, operations on int32 arrays are often faster than on int64 arrays because they involve less data to process.

Vectorization: NumPy operations are typically vectorized, meaning they operate on entire arrays at once. Using the appropriate data type ensures that these operations are efficient and leverage NumPy’s optimized routines.

* Compatibility and Precision:

Precision Requirements: Choosing the right data type ensures that calculations maintain the necessary precision. For example, using float16 might introduce rounding errors due to its limited precision, which may be unacceptable in certain calculations.

Compatibility: Some NumPy functions and operations expect specific data types. Using the wrong data type might result in errors or unintended behavior.

* Data Type Conversion: Sometimes you may need to convert the data type of an array for specific operations or to optimize memory usage. You can do this using the astype method:
"""

arr_float = arr.astype(np.float32)  # Convert array to float32

#Example on memory usage
import numpy as np
import sys

arr_int32 = np.array([1, 2, 3, 4, 5], dtype=np.int32)
arr_int64 = np.array([1, 2, 3, 4, 5], dtype=np.int64)

print("Size of int32 array:", arr_int32.nbytes, "bytes")
print("Size of int64 array:", arr_int64.nbytes, "bytes")

#Example on performance
import numpy as np
import time

# Define large arrays
arr_float32 = np.random.rand(1000000).astype(np.float32)
arr_float64 = np.random.rand(1000000).astype(np.float64)

# Time operations
start_time = time.time()
np.mean(arr_float32)
print("Time with float32:", time.time() - start_time)

start_time = time.time()
np.mean(arr_float64)
print("Time with float64:", time.time() - start_time)

"""**5. Define ndarrays in NumPy and explain their key features. How do they differ from standard Python lists.**

Ans: In NumPy, ndarray (short for "n-dimensional array") is the core data structure for handling numerical data. It is a powerful and flexible container for large datasets, providing numerous advantages over standard Python lists. Here’s a detailed overview of ndarray, its key features, and how it differs from Python lists.

An ndarray is a multidimensional, homogeneous array object that holds elements of the same data type. It provides efficient storage and manipulation of numerical data in a variety of dimensions (1D, 2D, 3D, and beyond).

* Key Features of ndarray

Homogeneous Data Types: All elements in an ndarray have the same data type, which ensures consistency and allows for efficient computations. You can specify the data type using the dtype attribute, e.g., np.int32, np.float64.

Multidimensional Arrays: ndarray can be one-dimensional (1D), two-dimensional (2D), or n-dimensional (nD). This flexibility allows for handling complex datasets like matrices, tensors, and more. The shape of an ndarray is described by a tuple of integers, representing the size along each dimension, e.g., (3, 4) for a 2D array with 3 rows and 4 columns.

Efficient Storage and Computation: ndarray uses contiguous memory blocks, which allows for efficient storage and computation. This layout optimizes performance for mathematical operations and slicing. Operations on ndarray are often vectorized, meaning they are applied to entire arrays at once, avoiding the need for explicit loops.

Element-wise Operations: NumPy supports element-wise operations, which means operations are applied independently to each element of the array. For example, adding two arrays performs element-wise addition.

Broadcasting: Broadcasting is a mechanism that allows NumPy to perform operations on arrays of different shapes. It automatically expands the smaller array to match the shape of the larger array for element-wise operations.

Slicing and Indexing: ndarray supports advanced slicing and indexing, including boolean indexing, integer indexing, and slicing with multiple dimensions. This provides powerful ways to access and modify parts of the array.

Mathematical Functions: NumPy provides a wide range of mathematical functions that can operate on entire arrays or on individual elements, including functions for linear algebra, statistics, and more.

Memory Layout: Arrays can have different memory layouts, such as row-major (C-style) or column-major (Fortran-style), which can affect performance in some cases.

* Differences Between ndarray and Standard Python Lists

Data Type Homogeneity:

ndarray: All elements must be of the same data type. Python Lists: Can contain elements of different data types. Performance:

ndarray: Provides efficient storage and computation due to its fixed-size data type and contiguous memory layout. Python Lists: Are less efficient for numerical operations, as they are dynamically typed and involve overhead for storing object references. Multidimensionality:

ndarray: Supports multidimensional arrays (2D, 3D, etc.) with operations across dimensions. Python Lists: Are inherently 1D. Multi-dimensional data structures require nested lists, which are less efficient and harder to manage. Element-wise Operations:

ndarray: Supports element-wise operations and vectorized computations. Python Lists: Do not natively support element-wise operations. You need to use explicit loops or list comprehensions. Broadcasting:

ndarray: Supports broadcasting for operations between arrays of different shapes. Python Lists: Do not support broadcasting. Operations require arrays or matrices of compatible shapes. Slicing and Indexing:

ndarray: Offers advanced slicing and indexing options, including multi-dimensional slicing. Python Lists: Provide basic slicing and indexing, but are limited to one dimension.
"""

#example on ndarray
import numpy as np

# Create a 2D NumPy array
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# Perform element-wise operation
result = arr * 2

print("Original array:\n", arr)
print("Resulting array:\n", result)

#example on pythonlist
# Create a 2D Python list
list_2d = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]

# Attempt element-wise operation
result_list = [[element * 2 for element in row] for row in list_2d]

print("Original list:\n", list_2d)
print("Resulting list:\n", result_list)

"""**6. Analyze the performance benefits of NumPy arrays over Python lists for large-scale numerical operations.**

Ans: When it comes to large-scale numerical operations, NumPy arrays offer significant performance benefits over standard Python lists. These benefits stem from several key aspects of NumPy's design and implementation. Here’s an analysis of the performance advantages:

* Efficient Memory Layout Contiguous Memory Allocation: NumPy arrays are stored in contiguous memory blocks. This allows for efficient access patterns and better cache utilization during computation. When elements are stored sequentially, accessing them in a loop or performing operations on them is faster because the CPU can prefetch and cache data effectively. Fixed Data Type: All elements in a NumPy array are of the same data type, which enables optimized memory usage. Python lists, on the other hand, are arrays of pointers to objects, and each element can be of a different type. This adds overhead for storing type information and object references.

* Vectorized Operations Element-wise Computation: NumPy performs operations element-wise using highly optimized C and Fortran libraries. This means operations like addition, multiplication, or mathematical functions are applied simultaneously to all elements of the array without the need for explicit Python loops. Reduced Overhead: NumPy’s vectorized operations bypass the overhead of Python’s dynamic type checking and method dispatch. Instead, the operations are executed in compiled code, which is significantly faster.

* Broadcasting Efficient Computations with Different Shapes: Broadcasting allows NumPy to perform arithmetic operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger one. This avoids the need for manual replication of data and reduces memory usage and computational overhead. Avoiding Loops: With broadcasting, you can avoid writing explicit loops for element-wise operations across different shapes. This reduces the amount of Python code and leverages optimized internal implementations.

* Optimized Mathematical Libraries Low-Level Libraries: NumPy relies on highly optimized libraries like BLAS (Basic Linear Algebra Subprograms) and LAPACK (Linear Algebra PACKage) for complex numerical operations such as matrix multiplication and solving linear systems. These libraries are implemented in low-level languages like C and Fortran, providing substantial performance improvements. Parallelization: Some of these libraries can take advantage of multi-core processors, further accelerating computations.

* Memory Efficiency Compact Storage: NumPy arrays use a fixed-size data type for all elements, which reduces memory overhead compared to Python lists, where each element is a separate object with its own metadata. Reduction in Memory Fragmentation: Contiguous memory allocation in NumPy arrays reduces memory fragmentation and improves cache locality, which enhances performance for large datasets.

* Advanced Indexing and Slicing Efficient Indexing: NumPy provides efficient indexing and slicing operations that are executed at the compiled level. These operations are faster compared to equivalent operations on Python lists, which involve additional Python overhead. Boolean Indexing and Advanced Features: NumPy supports boolean indexing, fancy indexing, and other advanced features that allow for efficient data manipulation and querying.

Performance Comparison Example To illustrate the performance benefits, consider the following example where we compare element-wise addition using NumPy arrays and Python lists:
"""

#ex NumPy
import numpy as np
import time

# Create large NumPy arrays
arr1 = np.random.rand(1000000)
arr2 = np.random.rand(1000000)

# Measure time for element-wise addition
start_time = time.time()
result = arr1 + arr2
end_time = time.time()

print("NumPy time:", end_time - start_time)

#ex Python List
import time

# Create large Python lists
list1 = list(np.random.rand(1000000))
list2 = list(np.random.rand(1000000))

# Measure time for element-wise addition
start_time = time.time()
result = [x + y for x, y in zip(list1, list2)]
end_time = time.time()

print("Python list time:", end_time - start_time)

"""Results and Interpretation NumPy: The operation on NumPy arrays will typically be an order of magnitude faster than the operation on Python lists. This is because the NumPy implementation is optimized and leverages low-level operations that are much faster than Python’s dynamic type handling and list comprehensions. Python Lists: The list comprehension method involves looping through Python objects, which adds significant overhead due to Python’s dynamic type checking and object management.

**7. Compare vstack() and hstack() functions in NumPy. Provide examples demonstrating their usage and output.**

Ans: In NumPy, vstack() and hstack() are functions used to stack arrays along different axes, allowing you to combine arrays either vertically or horizontally. Here’s a detailed comparison of these functions, along with examples demonstrating their usage:

* numpy.vstack() Purpose: Stacks arrays vertically (row-wise). It combines arrays by adding rows on top of each other. Axis: The arrays are concatenated along the vertical axis (axis 0).

Syntax: numpy.vstack(tup)

* tup: A sequence of arrays to be stacked. All arrays must have the same number of columns (i.e., the same number of columns).
"""

#ex
import numpy as np

# Create two 2D arrays
arr1 = np.array([[1, 2, 3],
                 [4, 5, 6]])

arr2 = np.array([[7, 8, 9],
                 [10, 11, 12]])

# Stack arrays vertically
result_vstack = np.vstack((arr1, arr2))

print("Result of vstack:")
print(result_vstack)

"""* numpy.hstack()

Purpose: Stacks arrays horizontally (column-wise). It combines arrays by adding columns side by side.
Axis: The arrays are concatenated along the horizontal axis.

Syntax:
numpy.hstack(tup)

tup: A sequence of arrays to be stacked. All arrays must have the same number of rows (i.e., the same number of rows).
"""

#ex
import numpy as np

# Create two 2D arrays
arr1 = np.array([[1, 2, 3],
                 [4, 5, 6]])

arr2 = np.array([[7, 8],
                 [9, 10]])

# Stack arrays horizontally
result_hstack = np.hstack((arr1, arr2))

print("Result of hstack:")
print(result_hstack)

"""**8.Explain the differences between fliplr() and flipud() methods in NumPy, including their effects on various array dimensions.**

Ans:In NumPy, the fliplr() and flipud() functions are used to reverse the order of elements in an array along different axes. Here’s a detailed explanation of the differences between these methods and their effects on various array dimensions:

* numpy.fliplr() Purpose: Reverses the order of elements in an array along the left-right axis (axis 1). This function is short for "flip left-right." Effect on 2D Arrays: It reverses the elements of each row, effectively flipping the array horizontally. Syntax: numpy.fliplr(m)

m: The input array. It must be at least 2-dimensional.


"""

#ex with 2D array
import numpy as np

# Create a 2D array
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# Flip array left-right
flipped_lr = np.fliplr(arr)

print("Original array:\n", arr)
print("Flipped left-right:\n", flipped_lr)

"""* numpy.flipud() Purpose: Reverses the order of elements in an array along the up-down axis (axis 0). This function is short for "flip up-down." Effect on 2D Arrays: It reverses the order of rows, effectively flipping the array vertically. Syntax: numpy.flipud(m)

m: The input array. It must be at least 2-dimensional.
"""

#ex on 2D array
import numpy as np

# Create a 2D array
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# Flip array up-down
flipped_ud = np.flipud(arr)

print("Original array:\n", arr)
print("Flipped up-down:\n", flipped_ud)

"""Differences Between fliplr() and flipud() 1)Axis of Operation: fliplr():

* Operates along the horizontal axis (axis 1), reversing the order of elements in each row. flipud(): Operates along the vertical axis (axis 0), reversing the order of rows.

* Effect on Array Dimensions: a)2D Arrays: fliplr(): Flips the array horizontally. Each row is reversed, but the order of rows remains unchanged. flipud(): Flips the array vertically. The order of rows is reversed, but the contents of each row remain unchanged.

* 1D Arrays: Both functions are not directly applicable to 1D arrays. For 1D arrays, you would use np.flip() to reverse the array in either direction.

* 3D Arrays and Higher:

For multi-dimensional arrays, fliplr() and flipud() can be used if the array is at least 2-dimensional, but their effect will depend on the specific axis.

fliplr(): Flips along the second axis (axis 1), affecting each 2D slice in the higher-dimensional array. flipud(): Flips along the first axis (axis 0), affecting each 2D slice in the higher-dimensional array.
"""

#ex with 3D array
import numpy as np

# Create a 3D array
arr_3d = np.array([[[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]],

                   [[10, 11, 12],
                    [13, 14, 15],
                    [16, 17, 18]]])

# Flip along axis 1 (left-right) for each 2D slice
flipped_lr_3d = np.fliplr(arr_3d)

# Flip along axis 0 (up-down) for the 3D array
flipped_ud_3d = np.flipud(arr_3d)

print("Original 3D array:\n", arr_3d)
print("Flipped left-right (3D):\n", flipped_lr_3d)
print("Flipped up-down (3D):\n", flipped_ud_3d)

"""**9. Discuss the functionality of the array_split() method in NumPy. How does it handle uneven splits.**

Ans: The array_split() method in NumPy is a versatile function for splitting an array into multiple sub-arrays. This function is useful for dividing data into chunks for processing or analysis. Here’s a detailed look at its functionality and how it handles uneven splits:

a)numpy.array_split() Purpose: To split an array into multiple sub-arrays along a specified axis. Syntax: numpy.array_split(ary, indices_or_sections, axis=0)

ary: The input array to be split. indices_or_sections: If an integer is provided, it specifies the number of equal-sized sub-arrays to create. If a sequence of indices is provided, it specifies the points at which to split the array. axis: The axis along which to split the array. The default is 0.

Handling Uneven Splits When splitting an array into an unequal number of sub-arrays (i.e., the size of the array is not evenly divisible by the number of sections), array_split() handles this gracefully:

1)Integer as indices_or_sections: If the array cannot be evenly divided, array_split() will create sub-arrays of different sizes. The result will be a list of sub-arrays where the first few sub-arrays are larger if there are remainders. For example, if you split an array of size 10 into 3 parts, you will get two sub-arrays of size 4 and one of size 2.

2)Sequence of Indices as indices_or_sections: If you specify a sequence of indices, array_split() will split the array at those indices. If the indices do not evenly divide the array, the last sub-array might be smaller or larger, depending on how the indices are specified.
"""

#ex1: splitting with an integer
import numpy as np

# Create an array
arr = np.arange(10)  # Array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Split the array into 3 parts
split_arr = np.array_split(arr, 3)

print("Split array (integer split):")
for sub_array in split_arr:
    print(sub_array)

#ex2: splitting with sequence of indices
import numpy as np

# Create an array
arr = np.arange(10)  # Array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Split the array at specific indices
split_arr = np.array_split(arr, [3, 7])

print("Split array (indices split):")
for sub_array in split_arr:
    print(sub_array)

"""**10. Explain the concepts of vectorization and broadcasting in NumPy. How do they contribute to efficient array
operations.**

Ans: Vectorization and broadcasting are two key concepts in NumPy that significantly enhance the efficiency and performance of array operations. Here’s an explanation of both concepts and how they contribute to efficient array operations:

* Vectorization Vectorization is a technique in NumPy that allows for operations to be performed on entire arrays rather than on individual elements. This is achieved by utilizing NumPy’s underlying C and Fortran libraries, which implement operations in compiled code. As a result, operations are executed much faster than equivalent operations implemented with explicit Python loops.

**Key Points**

* Element-wise Operations: Vectorization enables element-wise operations on arrays. For instance, adding two arrays together performs addition on each corresponding element simultaneously.

* Avoiding Python Loops: By avoiding explicit Python loops, vectorization reduces the overhead associated with Python’s dynamic typing and interpreter. Instead, operations are handled by optimized, low-level implementations.

* Improved Performance: Vectorized operations are typically several orders of magnitude faster than their Python loop counterparts due to the optimized implementation in compiled code.



"""

#example on vectorisation
import numpy as np

# Create two large NumPy arrays
arr1 = np.random.rand(1000000)
arr2 = np.random.rand(1000000)

# Vectorized addition
result = arr1 + arr2

"""In this example, arr1 + arr2 is computed in a vectorized manner, where each element of arr1 is added to the corresponding element of arr2 without explicit looping.

* Broadcasting Broadcasting is a mechanism that allows NumPy to perform operations on arrays of different shapes in a way that makes sense, without needing to manually align the shapes of the arrays. It automatically expands the smaller array to match the shape of the larger array, making it possible to perform element-wise operations even when the arrays have different dimensions.

Key Points

Rules for Broadcasting: Broadcasting follows specific rules to determine if two arrays can be broadcast together:

* If the arrays have different numbers of dimensions, the shape of the smaller array is padded with ones on the left.
* Two dimensions are compatible when: They are equal, or One of them is 1 If these conditions are not met, broadcasting fails.

Automatic Expansion: Broadcasting automatically expands the dimensions of the smaller array to match the dimensions of the larger array. This avoids the need to manually replicate data and reduces memory usage.

Efficient Computation: By using broadcasting, NumPy can avoid creating large intermediate arrays, which helps save memory and computational resources.
"""

#Example of Broadcasting
import numpy as np

# Create a 2D array and a 1D array
arr2d = np.array([[1, 2, 3],
                  [4, 5, 6]])

arr1d = np.array([10, 20, 30])

# Broadcasting: add 1D array to each row of the 2D array
result = arr2d + arr1d

print("Original 2D array:\n", arr2d)
print("1D array:\n", arr1d)
print("Result after broadcasting:\n", result)

"""In this example, the 1D array arr1d is broadcasted to match the shape of the 2D array arr2d, and the addition is performed element-wise.

Contribution to Efficient Array Operations

* Speed and Performance:

Vectorization: By executing operations in compiled code rather than Python loops, vectorization significantly speeds up computations. This is especially important for large-scale data processing tasks.

Broadcasting: Broadcasting allows for efficient operations on arrays of different shapes without requiring explicit data replication. This reduces both memory usage and computational overhead.

* Code Simplicity:

Vectorization: Simplifies code by eliminating the need for manual loops and conditionals, leading to more concise and readable code.

Broadcasting: Simplifies the handling of operations involving arrays of different shapes, avoiding the need for complex manipulation or alignment of array dimensions.

* Memory Efficiency:

Vectorization: Uses memory more efficiently by performing operations in a vectorized manner rather than creating large intermediate arrays.

Broadcasting: Avoids creating multiple copies of arrays by automatically aligning shapes, leading to more memory-efficient computations.

## Name: Shivanshu Singh Parihar
# Batch : September 2024
# Assignment Date: 25 Oct 2024
# Assignment : Numpy Practical
## Practical Questions:

###                                 Assignment -5

**1. Create a 3x3 NumPy array with random integers between 1 and 100. Then, interchange its rows and columns.**

Ans:
"""

import numpy as np

# Step 1: Create a 3x3 NumPy array with random integers between 1 and 100
array = np.random.randint(1, 101, size=(3, 3))

print("Original array:")
print(array)

# Step 2: Interchange rows and columns (transpose the array)
transposed_array = array.T

print("\nTransposed array:")
print(transposed_array)

"""**2. Generate a 1D NumPy array with 10 elements. Reshape it into a 2x5 array, then into a 5x2 array.**

Ans:
"""

import numpy as np

# Step 1: Generate a 1D NumPy array with 10 elements
array_1d = np.arange(10)  # You can also use np.random.randint if you prefer random values

print("Original 1D array:")
print(array_1d)

# Step 2: Reshape it into a 2x5 array
array_2x5 = array_1d.reshape(2, 5)

print("\nReshaped into 2x5 array:")
print(array_2x5)

# Step 3: Reshape it into a 5x2 array
array_5x2 = array_1d.reshape(5, 2)

print("\nReshaped into 5x2 array:")
print(array_5x2)

"""**3. Create a 4x4 NumPy array with random float values. Add a border of zeros around it, resulting in a 6x6 array.**

Ans:
"""

import numpy as np

# Step 1: Create a 4x4 NumPy array with random float values
array_4x4 = np.random.rand(4, 4)

print("Original 4x4 array with random float values:")
print(array_4x4)

# Step 2: Add a border of zeros around it to get a 6x6 array
# `pad_width` specifies the number of rows/columns of padding to add on each side
array_6x6 = np.pad(array_4x4, pad_width=1, mode='constant', constant_values=0)

print("\n6x6 array with a border of zeros:")
print(array_6x6)

"""**4. Using NumPy, create an array of integers from 10 to 60 with a step of 5.**

Ans:
"""

import numpy as np

# Create an array of integers from 10 to 60 with a step of 5
array = np.arange(10, 65, 5)

print("Array from 10 to 60 with a step of 5:")
print(array)

"""**5. Create a NumPy array of strings ['python', 'numpy', 'pandas']. Apply different case transformations (uppercase, lowercase, title case, etc.) to each element.**

Ans:
"""

import numpy as np

# Step 1: Create a NumPy array of strings
array = np.array(['python', 'numpy', 'pandas'])

# Step 2: Apply different case transformations to each element
uppercase_array = np.char.upper(array)
lowercase_array = np.char.lower(array)
titlecase_array = np.char.title(array)
capitalize_array = np.char.capitalize(array)

# Print the results
print("Original array:")
print(array)

print("\nUppercase transformation:")
print(uppercase_array)

print("\nLowercase transformation:")
print(lowercase_array)

print("\nTitlecase transformation:")
print(titlecase_array)

print("\nCapitalize transformation:")
print(capitalize_array)

"""**6. Generate a NumPy array of words. Insert a space between each character of every word in the array.**

Ans:
"""

import numpy as np

# Step 1: Create a NumPy array of words
words_array = np.array(['python', 'numpy', 'pandas'])

# Step 2: Insert a space between each character of every word in the array
# Use np.char.join to insert spaces between characters
spaced_words_array = np.char.join(' ', words_array)

# Print the result
print("Original array:")
print(words_array)

print("\nArray with spaces between each character:")
print(spaced_words_array)

"""**7. Create two 2D NumPy arrays and perform element-wise addition, subtraction, multiplication, and division.**

Ans:


"""

import numpy as np

# Step 1: Create two 2D NumPy arrays
array1 = np.array([[1, 2, 3], [4, 5, 6]])
array2 = np.array([[7, 8, 9], [10, 11, 12]])

# Step 2: Perform element-wise addition
addition_result = array1 + array2

# Step 3: Perform element-wise subtraction
subtraction_result = array1 - array2

# Step 4: Perform element-wise multiplication
multiplication_result = array1 * array2

# Step 5: Perform element-wise division
# To avoid division by zero, ensure no zeros in array2
division_result = array1 / array2

# Print the results
print("Array 1:")
print(array1)

print("\nArray 2:")
print(array2)

print("\nElement-wise addition:")
print(addition_result)

print("\nElement-wise subtraction:")
print(subtraction_result)

print("\nElement-wise multiplication:")
print(multiplication_result)

print("\nElement-wise division:")
print(division_result)

"""**8. Use NumPy to create a 5x5 identity matrix, then extract its diagonal elements.**

Ans:
"""

import numpy as np

# Step 1: Create a 5x5 identity matrix
identity_matrix = np.eye(5)

print("5x5 Identity Matrix:")
print(identity_matrix)

# Step 2: Extract the diagonal elements
diagonal_elements = np.diag(identity_matrix)

print("\nDiagonal elements:")
print(diagonal_elements)

"""**9. Generate a NumPy array of 100 random integers between 0 and 1000. Find and display all prime numbers in this array.**

Ans:
"""

import numpy as np

# Step 1: Generate a NumPy array of 100 random integers between 0 and 1000
array = np.random.randint(0, 1001, size=100)

# Function to check if a number is prime
def is_prime(n):
    """Return True if n is a prime number, else False."""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

# Step 2: Find all prime numbers in the array
primes = np.array([num for num in array if is_prime(num)])

# Print the results
print("Array of random integers:")
print(array)

print("\nPrime numbers in the array:")
print(primes)

"""**10. Create a NumPy array representing daily temperatures for a month. Calculate and display the weekly averages.**

Ans:
"""

import numpy as np

# Step 1: Create a NumPy array representing daily temperatures for a month (30 days)
# For simplicity, we'll generate random temperatures between 0 and 35 degrees Celsius
np.random.seed(0)  # Seed for reproducibility
daily_temperatures = np.random.randint(0, 36, size=30)

print("Daily temperatures for the month:")
print(daily_temperatures)

# Step 2: Reshape the array into a shape of (4, 7) for 4 weeks (assuming 30 days includes 4 full weeks)
# and 2 extra days; reshaping to 5x7 for simplicity to include all days
weekly_temperatures = daily_temperatures.reshape(3, 10)

# Step 3: Calculate weekly averages
weekly_averages = np.mean(weekly_temperatures, axis=1)

print("\nWeekly averages:")
print(weekly_averages)